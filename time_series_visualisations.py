# -*- coding: utf-8 -*-
"""time_series_visualisations.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Xqf-mo-Nedl-gb62oRGFzcymgh5WKesn
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import ipywidgets as widgets
from IPython.display import display, HTML
import matplotlib.cm as cm
from scipy import stats

def plot_item_sales_with_stats(item_id, df, freq='W'):
    """
    Plot sales data for a specific item with min-max range and display monthly statistics.

    Parameters:
    - item_id: The ID of the item to plot
    - df: DataFrame containing the sales data
    - freq: Frequency for resampling (default: 'W' for weekly)
    """
    # Filter data for the selected item
    df_item = df[df['item'] == item_id].copy()

    # Skip if no data available for this item
    if len(df_item) == 0:
        print(f"No data available for item {item_id}")
        return

    # Resample by the specified frequency for the plot
    df_plot = (
        df_item
        .groupby(pd.Grouper(freq=freq))
        .agg({'sales': ['mean', 'min', 'max']})
    )

    # Flatten the multi-index columns
    df_plot.columns = ['mean', 'min', 'max']

    # Create figure (make it a bit taller to accommodate the monthly stats table)
    plt.figure(figsize=(12, 8))

    # Plot mean line
    plt.plot(df_plot.index, df_plot['mean'], label='Average (across all stores)', color='blue', linewidth=2)

    # Fill between min and max
    plt.fill_between(
        df_plot.index,
        df_plot['min'],
        df_plot['max'],
        alpha=0.2,
        color='blue',
        label='Range [min, max]'
    )

    # Add title and labels
    plt.title(f'Sales Dynamics (Item={item_id})', fontsize=14)
    plt.xlabel('Date', fontsize=12)
    plt.ylabel('Sales', fontsize=12)
    plt.legend(fontsize=10)
    plt.grid(True, alpha=0.3)

    # Show the plot
    plt.tight_layout()
    plt.show()

    # Now create monthly statistics table
    # Add month column for grouping
    df_item['month'] = df_item.index.to_period('M')

    # Group by month and calculate statistics
    monthly_stats = df_item.groupby('month').agg({
        'sales': [
            ('Total', 'sum'),
            ('Average', 'mean'),
            ('Min', 'min'),
            ('Max', 'max'),
            ('Std Dev', 'std'),
            ('Count', 'count')
        ]
    })

    # Flatten multi-index columns
    monthly_stats.columns = monthly_stats.columns.droplevel()

    # Reset index for better display
    monthly_stats = monthly_stats.reset_index()

    # Convert period to string for display
    monthly_stats['month'] = monthly_stats['month'].astype(str)

    # Format numeric columns
    monthly_stats['Total'] = monthly_stats['Total'].round(2)
    monthly_stats['Average'] = monthly_stats['Average'].round(2)
    monthly_stats['Min'] = monthly_stats['Min'].round(2)
    monthly_stats['Max'] = monthly_stats['Max'].round(2)
    monthly_stats['Std Dev'] = monthly_stats['Std Dev'].round(2)

    # Display the monthly statistics table
    display(HTML("<h3>Monthly Statistics for Item {}</h3>".format(item_id)))

    # Style the dataframe for display
    styled_stats = monthly_stats.style.background_gradient(cmap='Blues', subset=['Total', 'Average'])
    styled_stats = styled_stats.format({
        'Total': '{:.1f}',
        'Average': '{:.1f}',
        'Min': '{:.1f}',
        'Max': '{:.1f}',
        'Std Dev': '{:.1f}'
    })

    display(styled_stats)

# Create interactive widget with monthly statistics
def interactive_sales_plot_with_stats(df):
    """
    Create an interactive plot with a slider to choose item ID and display monthly statistics.

    Parameters:
    - df: DataFrame containing the sales data
    """
    # Get available item IDs from the data
    available_items = sorted(df['item'].unique())
    min_item = min(available_items)
    max_item = max(available_items)

    # Create a slider widget for item selection
    item_slider = widgets.IntSlider(
        value=min_item,
        min=min_item,
        max=max_item,
        step=1,
        description='Item ID:',
        continuous_update=False,
        layout=widgets.Layout(width='500px')
    )

    # Create a dropdown for frequency selection
    freq_dropdown = widgets.Dropdown(
        options=[
            ('Daily', 'D'),
            ('Weekly', 'W'),
            ('Monthly', 'ME')
        ],
        value='W',
        description='Frequency:',
        layout=widgets.Layout(width='200px')
    )

    # Create the interactive output
    output = widgets.Output()

    # Define the update function
    def update_plot(change):
        with output:
            output.clear_output(wait=True)
            plot_item_sales_with_stats(item_slider.value, df, freq_dropdown.value)

    # Register the update function with the widgets
    item_slider.observe(update_plot, names='value')
    freq_dropdown.observe(update_plot, names='value')

    # Display the widgets and initial plot
    display(widgets.HBox([item_slider, freq_dropdown]))
    display(output)

    # Show the initial plot
    with output:
        plot_item_sales_with_stats(item_slider.value, df, freq_dropdown.value)

# Example usage with sample data (if needed)
def create_sample_data():
    """Create sample data for demonstration"""
    # Create date range for the past year
    dates = pd.date_range(start='2023-01-01', end='2023-12-31', freq='D')

    # Create records for items across multiple stores
    records = []

    # Generate stores
    stores = range(1, 6)

    # Generate items
    items = range(1, 11)

    # For each date, item, and store combination
    for date in dates:
        for item in items:
            # Base sales value that varies by item
            base_sales = np.random.normal(100 * (item % 5 + 1), 20)

            # Add seasonality (higher in summer, lower in winter)
            month = date.month
            season_factor = 1 + 0.3 * np.sin((month - 1) * np.pi / 6)

            for store in stores:
                # Store-specific variation
                store_factor = 0.7 + (store * 0.15)

                # Calculate final sales with some randomness
                sales = max(0, base_sales * season_factor * store_factor *
                           np.random.normal(1, 0.2))

                records.append({
                    'date': date,
                    'item': item,
                    'store': store,
                    'sales': sales
                })

    # Create DataFrame
    df = pd.DataFrame(records)

    # Set the date as index
    df.set_index('date', inplace=True)

    return df

def plot_item_across_stores(item_id, df, selected_stores=None, freq='W'):
    """
    Plot sales data for a specific item across different stores.

    Parameters:
    - item_id: The ID of the item to plot
    - df: DataFrame containing the sales data
    - selected_stores: List of store IDs to include (None for all)
    - freq: Frequency for resampling (default: 'W' for weekly)
    """
    # Filter data for the selected item
    df_item = df[df['item'] == item_id].copy()

    # Get all available stores
    all_stores = sorted(df_item['store'].unique())


    # Create the figure
    plt.figure(figsize=(14, 8))

    # Get colormap for different stores
    colormap = plt.get_cmap('tab10', len(selected_stores))

    # For calculating the overall average
    all_store_data = []

    # Plot each store
    for i, store_id in enumerate(selected_stores):
        # Filter for this store
        df_store = df_item[df_item['store'] == store_id].copy()

        # Resample by the specified frequency
        df_store = (
            df_store
            .groupby(pd.Grouper(freq=freq))
            .agg({'sales': 'mean'})
        )

        all_store_data.append(df_store)

        # Plot this store's data
        plt.plot(
            df_store.index,
            df_store['sales'],
            label=f'Store {store_id}',
            color=colormap(i),
            alpha=0.8,
            linewidth=2
        )

    # Calculate and plot the average across selected stores
    if len(all_store_data) > 1:
        # Concatenate all store data
        combined_data = pd.concat(all_store_data)
        # Group by date index to get average across stores
        avg_data = combined_data.groupby(level=0).mean()

        plt.plot(
            avg_data.index,
            avg_data['sales'],
            label='Average Across Stores',
            color='black',
            linestyle='--',
            linewidth=3
        )

    # Add title and labels
    plt.title(f'Sales Dynamics for Item {item_id} Across Stores', fontsize=14)
    plt.xlabel('Date', fontsize=12)
    plt.ylabel('Sales', fontsize=12)
    plt.grid(True, alpha=0.3)

    # Add legend (place it outside the plot area if many stores)
    if len(selected_stores) > 5:
        plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left', fontsize=10)
    else:
        plt.legend(fontsize=10)

    # Show the plot
    plt.tight_layout()
    plt.show()

# Create interactive widget with store selection
def interactive_store_comparison(df):
    """
    Create an interactive plot with widgets to choose item ID and stores.

    Parameters:
    - df: DataFrame containing the sales data
    """
    # Get available item IDs from the data
    available_items = sorted(df['item'].unique())
    min_item = min(available_items)
    max_item = max(available_items)

    # Get available store IDs
    available_stores = sorted(df['store'].unique())

    # Create a slider widget for item selection
    item_slider = widgets.IntSlider(
        value=min_item,
        min=min_item,
        max=max_item,
        step=1,
        description='Item ID:',
        continuous_update=False,
        layout=widgets.Layout(width='500px')
    )

    # Create checkboxes for store selection
    store_checks = [widgets.Checkbox(
        value=True,  # Initially selected
        description=f'Store {store_id}',
        layout=widgets.Layout(width='100px')
    ) for store_id in available_stores]

    # Button to select/deselect all stores
    select_all_button = widgets.Button(
        description='Select All',
        layout=widgets.Layout(width='100px')
    )

    deselect_all_button = widgets.Button(
        description='Deselect All',
        layout=widgets.Layout(width='100px')
    )

    # Function to handle select/deselect all
    def select_all(b):
        for check in store_checks:
            check.value = True

    def deselect_all(b):
        for check in store_checks:
            check.value = False

    # Register button callbacks
    select_all_button.on_click(select_all)
    deselect_all_button.on_click(deselect_all)

    # Create a dropdown for frequency selection
    freq_dropdown = widgets.Dropdown(
        options=[
            ('Weekly', 'W'),
            ('Monthly', 'M')
        ],
        value='W',
        description='Frequency:',
        layout=widgets.Layout(width='200px')
    )

    # Create the interactive output
    output = widgets.Output()

    # Define the update function
    def update_plot(change):
        # Get selected stores
        selected_stores = [
            store_id for i, store_id in enumerate(available_stores)
            if store_checks[i].value
        ]

        with output:
            output.clear_output(wait=True)
            plot_item_across_stores(
                item_slider.value,
                df,
                selected_stores=selected_stores,
                freq=freq_dropdown.value
            )

    # Register the update function with the widgets
    item_slider.observe(update_plot, names='value')
    freq_dropdown.observe(update_plot, names='value')

    # Add observers for all checkboxes
    for check in store_checks:
        check.observe(update_plot, names='value')

    # Arrange widgets in a box layout
    controls_top = widgets.HBox([item_slider, freq_dropdown])
    store_selection = widgets.HBox([widgets.VBox([select_all_button, deselect_all_button]),
                                   widgets.HBox(store_checks)])

    # Display all widgets
    display(widgets.VBox([controls_top, store_selection, output]))

    # Show the initial plot
    # Get initially selected stores (all)
    selected_stores = available_stores

    with output:
        plot_item_across_stores(
            item_slider.value,
            df,
            selected_stores=selected_stores,
            freq=freq_dropdown.value
        )

def plot_item_across_stores_with_ci(item_id, df, selected_stores=None, freq='W', ci_level=0.95):
    """
    Plot sales data for a specific item across different stores with confidence intervals.

    Parameters:
    - item_id: The ID of the item to plot
    - df: DataFrame containing the sales data
    - selected_stores: List of store IDs to include (None for all)
    - freq: Frequency for resampling (default: 'W' for weekly)
    - ci_level: Confidence interval level (default: 0.95 for 95% CI)
    """
    # Filter data for the selected item
    df_item = df[df['item'] == item_id].copy()

    # Skip if no data available for this item
    if len(df_item) == 0:
        print(f"No data available for item {item_id}")
        return

    # Get all available stores
    all_stores = sorted(df_item['store'].unique())

    # If no stores specified, use all available stores
    if selected_stores is None:
        selected_stores = all_stores
    else:
        # Filter to only include available stores
        selected_stores = [s for s in selected_stores if s in all_stores]

    # Skip if no stores to plot
    if len(selected_stores) == 0:
        print(f"No store data available for item {item_id}")
        return

    # Create the figure
    plt.figure(figsize=(14, 8))

    # Get colormap for different stores
    colormap = plt.get_cmap('tab10', len(selected_stores))

    # For calculating the overall average
    all_store_data = []

    # Plot each store
    for i, store_id in enumerate(selected_stores):
        # Filter for this store
        df_store = df_item[df_item['store'] == store_id].copy()

        # Resample by the specified frequency
        resampled = df_store.resample(freq)

        # Calculate mean and std for confidence intervals
        df_agg = pd.DataFrame({
            'mean': resampled['sales'].mean(),
            'std': resampled['sales'].std(),
            'count': resampled['sales'].count()
        })

        # Skip periods with no data
        df_agg = df_agg.dropna()

        # Calculate confidence interval
        z_score = stats.norm.ppf((1 + ci_level) / 2)
        df_agg['ci_margin'] = z_score * (df_agg['std'] / np.sqrt(df_agg['count']))
        df_agg['ci_lower'] = df_agg['mean'] - df_agg['ci_margin']
        df_agg['ci_upper'] = df_agg['mean'] + df_agg['ci_margin']

        all_store_data.append(df_agg)

        # Plot this store's data with confidence interval
        plt.plot(
            df_agg.index,
            df_agg['mean'],
            label=f'Store {store_id}',
            color=colormap(i),
            alpha=0.8,
            linewidth=2
        )

        # Fill the confidence interval
        plt.fill_between(
            df_agg.index,
            df_agg['ci_lower'],
            df_agg['ci_upper'],
            color=colormap(i),
            alpha=0.15
        )

    # Calculate and plot the average across selected stores with CI
    if len(all_store_data) > 1:
        # Join all store data on date index
        avg_data_list = []
        for i, df_store in enumerate(all_store_data):
            temp_df = df_store[['mean']].copy()
            temp_df.columns = [f'store_{selected_stores[i]}']
            avg_data_list.append(temp_df)

        # Merge all store data
        if avg_data_list:
            all_means = pd.concat(avg_data_list, axis=1)

            # Calculate the mean across stores for each time period
            all_means['overall_mean'] = all_means.mean(axis=1)

            # Calculate standard error and confidence interval across stores
            all_means['overall_std'] = all_means.std(axis=1)
            all_means['store_count'] = all_means.count(axis=1) - 1  # Subtract 1 for the mean column
            all_means['overall_ci'] = z_score * (all_means['overall_std'] / np.sqrt(all_means['store_count']))
            all_means['overall_ci_lower'] = all_means['overall_mean'] - all_means['overall_ci']
            all_means['overall_ci_upper'] = all_means['overall_mean'] + all_means['overall_ci']

            # Plot the overall mean
            plt.plot(
                all_means.index,
                all_means['overall_mean'],
                label='Average Across Stores',
                color='black',
                linestyle='--',
                linewidth=3
            )

            # Fill the confidence interval for overall mean
            plt.fill_between(
                all_means.index,
                all_means['overall_ci_lower'],
                all_means['overall_ci_upper'],
                color='black',
                alpha=0.1
            )

    # Add title and labels
    plt.title(f'Sales Dynamics for Item {item_id} Across Stores ({int(ci_level*100)}% CI)', fontsize=14)
    plt.xlabel('Date', fontsize=12)
    plt.ylabel('Sales', fontsize=12)
    plt.grid(True, alpha=0.3)

    # Add legend (place it outside the plot area if many stores)
    if len(selected_stores) > 5:
        plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left', fontsize=10)
    else:
        plt.legend(fontsize=10)

    # Show the plot
    plt.tight_layout()
    plt.show()

# Create interactive widget with store selection and CI level
def interactive_store_comparison_with_ci(df):
    """
    Create an interactive plot with widgets to choose item ID, stores, and confidence interval.

    Parameters:
    - df: DataFrame containing the sales data
    """
    # Get available item IDs from the data
    available_items = sorted(df['item'].unique())
    min_item = min(available_items)
    max_item = max(available_items)

    # Get available store IDs
    available_stores = sorted(df['store'].unique())

    # Create a slider widget for item selection
    item_slider = widgets.IntSlider(
        value=min_item,
        min=min_item,
        max=max_item,
        step=1,
        description='Item ID:',
        continuous_update=False,
        layout=widgets.Layout(width='500px')
    )

    # Create checkboxes for store selection
    store_checks = [widgets.Checkbox(
        value=True,  # Initially selected
        description=f'Store {store_id}',
        layout=widgets.Layout(width='100px')
    ) for store_id in available_stores]

    # Button to select/deselect all stores
    select_all_button = widgets.Button(
        description='Select All',
        layout=widgets.Layout(width='100px')
    )

    deselect_all_button = widgets.Button(
        description='Deselect All',
        layout=widgets.Layout(width='100px')
    )

    # Function to handle select/deselect all
    def select_all(b):
        for check in store_checks:
            check.value = True

    def deselect_all(b):
        for check in store_checks:
            check.value = False

    # Register button callbacks
    select_all_button.on_click(select_all)
    deselect_all_button.on_click(deselect_all)

    # Create a dropdown for frequency selection
    freq_dropdown = widgets.Dropdown(
        options=[
            ('Weekly', 'W'),
            ('Monthly', 'M')
        ],
        value='W',
        description='Frequency:',
        layout=widgets.Layout(width='150px')
    )

    # Create a slider for confidence interval level
    ci_slider = widgets.FloatSlider(
        value=0.95,
        min=0.5,
        max=0.99,
        step=0.01,
        description='CI Level:',
        continuous_update=False,
        layout=widgets.Layout(width='300px')
    )

    # Add a tooltip for CI explanation
    ci_help = widgets.HTML(
        value="<span style='color:gray;font-style:italic;'>Confidence interval width</span>",
        layout=widgets.Layout(width='150px')
    )

    # Create the interactive output
    output = widgets.Output()

    # Define the update function
    def update_plot(change):
        # Get selected stores
        selected_stores = [
            store_id for i, store_id in enumerate(available_stores)
            if store_checks[i].value
        ]

        with output:
            output.clear_output(wait=True)
            plot_item_across_stores_with_ci(
                item_slider.value,
                df,
                selected_stores=selected_stores,
                freq=freq_dropdown.value,
                ci_level=ci_slider.value
            )

    # Register the update function with the widgets
    item_slider.observe(update_plot, names='value')
    freq_dropdown.observe(update_plot, names='value')
    ci_slider.observe(update_plot, names='value')

    # Add observers for all checkboxes
    for check in store_checks:
        check.observe(update_plot, names='value')

    # Arrange widgets in a box layout
    controls_top = widgets.HBox([item_slider, freq_dropdown])
    controls_ci = widgets.HBox([ci_slider, ci_help])
    store_selection_buttons = widgets.VBox([select_all_button, deselect_all_button])

    # Arrange store checkboxes in a single row for 10 stores
    store_grid = widgets.GridBox(
        store_checks,
        layout=widgets.Layout(
            grid_template_columns="repeat(10, 100px)",  # 10 columns, one for each store
              grid_gap="10px"  # Space between checkboxes
        )
    )

    store_selection = widgets.HBox([store_selection_buttons, store_grid])

    # Display all widgets
    display(widgets.VBox([controls_top, controls_ci, store_selection, output]))

    # Show the initial plot
    # Get initially selected stores (all)
    selected_stores = available_stores

    with output:
        plot_item_across_stores_with_ci(
            item_slider.value,
            df,
            selected_stores=selected_stores,
            freq=freq_dropdown.value,
            ci_level=ci_slider.value
        )


def daily_item_dynamics(df):
    """
    Create an interactive plot with widgets to choose items (1-50) and month-year periods
    from January 2013 to December 2017.

    Parameters:
    - df: DataFrame containing the sales data with DatetimeIndex
          and columns 'store', 'item', and 'sales'
    """
    # Check if the index is a DatetimeIndex
    if not isinstance(df.index, pd.DatetimeIndex):
        print("Warning: DataFrame index is not a DatetimeIndex.")
        print("Attempting to convert to DatetimeIndex...")
        try:
            # Try to get date from index or column
            if 'date' in df.columns:
                df = df.set_index('date')
            df.index = pd.to_datetime(df.index)
        except Exception as e:
            print(f"Error converting to DatetimeIndex: {e}")
            print("Please ensure your DataFrame has a date index or a 'date' column.")
            return

    # Make a copy of the dataframe
    df_copy = df.copy()
    
    # Add year and month columns for filtering
    df_copy['year'] = df_copy.index.year
    df_copy['month'] = df_copy.index.month
    
    # Create list of items from 1 to 50
    available_items = list(range(1, 51))
    
    # Create list of year-month combinations from Jan 2013 to Dec 2017
    year_months = []
    for year in range(2013, 2018):
        for month in range(1, 13):
            # Convert month number to month name
            month_name = pd.to_datetime(f"2000-{month}-1").strftime('%B')
            year_months.append((f"{month_name} {year}", (year, month)))
    
    # Create a slider for item selection (1-50)
    item_slider = widgets.IntSlider(
        value=1,  # Start with item 1
        min=1,
        max=50,
        step=1,
        description='Item ID:',
        continuous_update=False,  # Only update when slider is released
        orientation='horizontal',
        readout=True,
        readout_format='d',
        style={'description_width': 'initial'},
        layout=widgets.Layout(width='80%')
    )
    
    # Create a label to show the selected item
    selected_item_label = widgets.Label(
        value=f"Selected: Item {item_slider.value}",
        layout=widgets.Layout(padding='5px')
    )
    
    # Function to update the item label when slider changes
    def update_item_label(change):
        selected_item_label.value = f"Selected: Item {change['new']}"
    
    # Register the update function
    item_slider.observe(update_item_label, names='value')
    
    # Create a dropdown for month-year selection
    month_year_dropdown = widgets.Dropdown(
        options=year_months,
        value=year_months[0][1] if year_months else None,
        description='Period:',
        layout=widgets.Layout(width='250px')
    )
    
    # Create the interactive output
    output = widgets.Output()
    
    # Define the plotting function
    def plot_items_for_period(dataframe, selected_item, year_month):
        """
        Plot sales data for the selected item during a specific month-year.
        """
        year, month = year_month
        
        # Filter data for the selected month and year
        period_data = dataframe[(dataframe['year'] == year) & (dataframe['month'] == month)].copy()
        
        # Filter by item
        item_data = period_data[period_data['item'] == selected_item]
        
        if item_data.empty:
            print(f"No data found for Item {selected_item} in {pd.to_datetime(f'{year}-{month}-1').strftime('%B %Y')}.")
            return
        
        # Create a figure with appropriate size
        plt.figure(figsize=(12, 6))
        
        # Get unique date values (days of the month)
        days = sorted(item_data.index.day.unique())
        
        # Group by day and get mean sales per day
        daily_sales = item_data.groupby(item_data.index.day)['sales'].mean()
        
        # Make sure we have data for all days in the month
        all_days = list(range(1, pd.Timestamp(year, month, 1).days_in_month + 1))
        plot_days = []
        plot_sales = []
        
        for day in all_days:
            plot_days.append(day)
            if day in daily_sales.index:
                plot_sales.append(daily_sales[day])
            else:
                plot_sales.append(np.nan)  # Use NaN for missing days
        
        # Plot the data
        plt.plot(plot_days, plot_sales, 'o-', color='#1f77b4', label=f'Item {selected_item}')
        
        # Set title and labels
        month_name = pd.to_datetime(f"{year}-{month}-1").strftime('%B %Y')
        plt.title(f"Daily Sales for Item {selected_item} in {month_name}")
        plt.xlabel("Day of Month")
        plt.ylabel("Average Sales")
        plt.grid(True, linestyle='--', alpha=0.7)
        
        # Set x-axis ticks to show all days
        plt.xticks(all_days)
        
        # Enhanced weekend highlighting
        ax = plt.gca()
        for label in ax.get_xticklabels():
            try:
                day = int(label.get_text())
                date = pd.Timestamp(year=year, month=month, day=day)
                
                # Check if it's a weekend (5=Saturday, 6=Sunday)
                if date.dayofweek >= 5:  # Weekend
                    label.set_color('red')
                    label.set_weight('bold')
                    
                    # Add background highlight for weekend days
                    plt.axvspan(day-0.5, day+0.5, alpha=0.2, color='red')
            except ValueError:
                # Skip any non-numeric labels
                continue
        
        # Adjust layout
        plt.tight_layout()
        
        plt.show()
    
    # Define the update function
    def update_plot(change):
        # Get selected item
        selected_item = item_slider.value
        
        # Get selected month-year
        year_month = month_year_dropdown.value
        
        with output:
            output.clear_output(wait=True)
            plot_items_for_period(
                df_copy,
                selected_item,
                year_month
            )
    
    # Register the update function with the widgets
    item_slider.observe(update_plot, names='value')
    month_year_dropdown.observe(update_plot, names='value')
    
    # Position period dropdown above graph, and item slider at the top
    item_controls = widgets.HBox([
        widgets.VBox([
            item_slider,
            selected_item_label
        ]),
    ])
    
    period_control = widgets.HBox([
        widgets.Label("Period:"),
        month_year_dropdown
    ])
    
    # Display all widgets with period control above the graph
    display(widgets.VBox([item_controls, period_control, output]))
    
    # Show the initial plot
    with output:
        plot_items_for_period(
            df_copy,
            item_slider.value,
            month_year_dropdown.value
        )